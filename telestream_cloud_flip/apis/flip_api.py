# coding: utf-8

"""
    Flip API

    Description

    OpenAPI spec version: 3.1.0
    Contact: cloudsupport@telestream.net
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class FlipApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def cancel_encoding(self, id, factory_id, **kwargs):
        """
        Cancels an Encoding.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.cancel_encoding(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: CanceledResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.cancel_encoding_with_http_info(id, factory_id, **kwargs)
        else:
            (data) = self.cancel_encoding_with_http_info(id, factory_id, **kwargs)
            return data

    def cancel_encoding_with_http_info(self, id, factory_id, **kwargs):
        """
        Cancels an Encoding.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.cancel_encoding_with_http_info(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: CanceledResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'factory_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_encoding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `cancel_encoding`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `cancel_encoding`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/encodings/{id}/cancel.json', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CanceledResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def copy_profile(self, id, factory_id, copy_profile_body, **kwargs):
        """
        Copies a given Profile
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.copy_profile(id, factory_id, copy_profile_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of a Profile. (required)
        :param str factory_id: Id of a Factory. (required)
        :param CopyProfileBody copy_profile_body: (required)
        :param bool expand: If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set.
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.copy_profile_with_http_info(id, factory_id, copy_profile_body, **kwargs)
        else:
            (data) = self.copy_profile_with_http_info(id, factory_id, copy_profile_body, **kwargs)
            return data

    def copy_profile_with_http_info(self, id, factory_id, copy_profile_body, **kwargs):
        """
        Copies a given Profile
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.copy_profile_with_http_info(id, factory_id, copy_profile_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of a Profile. (required)
        :param str factory_id: Id of a Factory. (required)
        :param CopyProfileBody copy_profile_body: (required)
        :param bool expand: If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set.
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'factory_id', 'copy_profile_body', 'expand']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `copy_profile`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `copy_profile`")
        # verify the required parameter 'copy_profile_body' is set
        if ('copy_profile_body' not in params) or (params['copy_profile_body'] is None):
            raise ValueError("Missing the required parameter `copy_profile_body` when calling `copy_profile`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))
        if 'expand' in params:
            query_params.append(('expand', params['expand']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'copy_profile_body' in params:
            body_params = params['copy_profile_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/profiles/{id}/copy.json', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Profile',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_encoding(self, factory_id, create_encoding_body, **kwargs):
        """
        Creates an Encoding
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_encoding(factory_id, create_encoding_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param CreateEncodingBody create_encoding_body: (required)
        :param bool screenshots: Determines whether the response will include screenshots. By default this is not set.
        :param bool precise_status: Determines whether the response will include a precise status. By default this is not set.
        :return: Encoding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_encoding_with_http_info(factory_id, create_encoding_body, **kwargs)
        else:
            (data) = self.create_encoding_with_http_info(factory_id, create_encoding_body, **kwargs)
            return data

    def create_encoding_with_http_info(self, factory_id, create_encoding_body, **kwargs):
        """
        Creates an Encoding
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_encoding_with_http_info(factory_id, create_encoding_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param CreateEncodingBody create_encoding_body: (required)
        :param bool screenshots: Determines whether the response will include screenshots. By default this is not set.
        :param bool precise_status: Determines whether the response will include a precise status. By default this is not set.
        :return: Encoding
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['factory_id', 'create_encoding_body', 'screenshots', 'precise_status']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_encoding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `create_encoding`")
        # verify the required parameter 'create_encoding_body' is set
        if ('create_encoding_body' not in params) or (params['create_encoding_body'] is None):
            raise ValueError("Missing the required parameter `create_encoding_body` when calling `create_encoding`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))
        if 'screenshots' in params:
            query_params.append(('screenshots', params['screenshots']))
        if 'precise_status' in params:
            query_params.append(('precise_status', params['precise_status']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_encoding_body' in params:
            body_params = params['create_encoding_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/encodings.json', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Encoding',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_factory(self, create_factory_body, **kwargs):
        """
        Creates a new factory
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_factory(create_factory_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param FactoryBody create_factory_body: (required)
        :param bool with_storage_provider: if set to `true`, results will include a storage provider's id
        :return: Factory
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_factory_with_http_info(create_factory_body, **kwargs)
        else:
            (data) = self.create_factory_with_http_info(create_factory_body, **kwargs)
            return data

    def create_factory_with_http_info(self, create_factory_body, **kwargs):
        """
        Creates a new factory
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_factory_with_http_info(create_factory_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param FactoryBody create_factory_body: (required)
        :param bool with_storage_provider: if set to `true`, results will include a storage provider's id
        :return: Factory
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['create_factory_body', 'with_storage_provider']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_factory" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'create_factory_body' is set
        if ('create_factory_body' not in params) or (params['create_factory_body'] is None):
            raise ValueError("Missing the required parameter `create_factory_body` when calling `create_factory`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'with_storage_provider' in params:
            query_params.append(('with_storage_provider', params['with_storage_provider']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_factory_body' in params:
            body_params = params['create_factory_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/factories.json', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Factory',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_profile(self, factory_id, create_profile_body, **kwargs):
        """
        Creates a Profile
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_profile(factory_id, create_profile_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param ProfileBody create_profile_body: (required)
        :param bool exclude_advanced_services:
        :param bool expand: If expand option is set Profile objects will contain all command parameters, even if their value is default. By default it is not set.
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_profile_with_http_info(factory_id, create_profile_body, **kwargs)
        else:
            (data) = self.create_profile_with_http_info(factory_id, create_profile_body, **kwargs)
            return data

    def create_profile_with_http_info(self, factory_id, create_profile_body, **kwargs):
        """
        Creates a Profile
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_profile_with_http_info(factory_id, create_profile_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param ProfileBody create_profile_body: (required)
        :param bool exclude_advanced_services:
        :param bool expand: If expand option is set Profile objects will contain all command parameters, even if their value is default. By default it is not set.
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['factory_id', 'create_profile_body', 'exclude_advanced_services', 'expand']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `create_profile`")
        # verify the required parameter 'create_profile_body' is set
        if ('create_profile_body' not in params) or (params['create_profile_body'] is None):
            raise ValueError("Missing the required parameter `create_profile_body` when calling `create_profile`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))
        if 'exclude_advanced_services' in params:
            query_params.append(('exclude_advanced_services', params['exclude_advanced_services']))
        if 'expand' in params:
            query_params.append(('expand', params['expand']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_profile_body' in params:
            body_params = params['create_profile_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/profiles.json', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Profile',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_workorder(self, factory_id, **kwargs):
        """
        Creates a Workorder.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_workorder(factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param str profile_id: Id of a Profile.
        :param file file: Input file.
        :param str source_url: URL pointing to an input file.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_workorder_with_http_info(factory_id, **kwargs)
        else:
            (data) = self.create_workorder_with_http_info(factory_id, **kwargs)
            return data

    def create_workorder_with_http_info(self, factory_id, **kwargs):
        """
        Creates a Workorder.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_workorder_with_http_info(factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param str profile_id: Id of a Profile.
        :param file file: Input file.
        :param str source_url: URL pointing to an input file.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['factory_id', 'profile_id', 'file', 'source_url']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_workorder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `create_workorder`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'profile_id' in params:
            form_params.append(('profile_id', params['profile_id']))
        if 'file' in params:
            local_var_files['file'] = params['file']
        if 'source_url' in params:
            form_params.append(('source_url', params['source_url']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/workorders.json', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_encoding(self, id, factory_id, **kwargs):
        """
        Deletes an Encoding from both Telestream Cloud and your storage. Returns an information whether the operation was successful.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_encoding(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: DeletedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_encoding_with_http_info(id, factory_id, **kwargs)
        else:
            (data) = self.delete_encoding_with_http_info(id, factory_id, **kwargs)
            return data

    def delete_encoding_with_http_info(self, id, factory_id, **kwargs):
        """
        Deletes an Encoding from both Telestream Cloud and your storage. Returns an information whether the operation was successful.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_encoding_with_http_info(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: DeletedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'factory_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_encoding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_encoding`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `delete_encoding`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/encodings/{id}.json', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DeletedResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_profile(self, id, factory_id, **kwargs):
        """
        Deletes a given Profile
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_profile(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of a Profile (required)
        :param str factory_id: Id of a Factory. (required)
        :return: DeletedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_profile_with_http_info(id, factory_id, **kwargs)
        else:
            (data) = self.delete_profile_with_http_info(id, factory_id, **kwargs)
            return data

    def delete_profile_with_http_info(self, id, factory_id, **kwargs):
        """
        Deletes a given Profile
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_profile_with_http_info(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of a Profile (required)
        :param str factory_id: Id of a Factory. (required)
        :return: DeletedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'factory_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_profile`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `delete_profile`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/profiles/{id}.json', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DeletedResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_video(self, id, factory_id, **kwargs):
        """
        Deletes a Video object.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_video(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: DeletedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_video_with_http_info(id, factory_id, **kwargs)
        else:
            (data) = self.delete_video_with_http_info(id, factory_id, **kwargs)
            return data

    def delete_video_with_http_info(self, id, factory_id, **kwargs):
        """
        Deletes a Video object.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_video_with_http_info(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: DeletedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'factory_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_video" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_video`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `delete_video`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/videos/{id}.json', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DeletedResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_video_source(self, id, factory_id, **kwargs):
        """
        Delete a video's source file.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_video_source(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: DeletedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_video_source_with_http_info(id, factory_id, **kwargs)
        else:
            (data) = self.delete_video_source_with_http_info(id, factory_id, **kwargs)
            return data

    def delete_video_source_with_http_info(self, id, factory_id, **kwargs):
        """
        Delete a video's source file.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_video_source_with_http_info(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: DeletedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'factory_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_video_source" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_video_source`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `delete_video_source`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/videos/{id}/source.json', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DeletedResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def encoding(self, id, factory_id, **kwargs):
        """
        Returns an Encoding object.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.encoding(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param bool screenshots: Determines whether the response will include screenshots. By default this is not set.
        :param bool precise_status: Determines whether the response will include a precise status. By default this is not set.
        :return: Encoding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.encoding_with_http_info(id, factory_id, **kwargs)
        else:
            (data) = self.encoding_with_http_info(id, factory_id, **kwargs)
            return data

    def encoding_with_http_info(self, id, factory_id, **kwargs):
        """
        Returns an Encoding object.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.encoding_with_http_info(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param bool screenshots: Determines whether the response will include screenshots. By default this is not set.
        :param bool precise_status: Determines whether the response will include a precise status. By default this is not set.
        :return: Encoding
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'factory_id', 'screenshots', 'precise_status']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method encoding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `encoding`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `encoding`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))
        if 'screenshots' in params:
            query_params.append(('screenshots', params['screenshots']))
        if 'precise_status' in params:
            query_params.append(('precise_status', params['precise_status']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/encodings/{id}.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Encoding',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def encodings(self, factory_id, **kwargs):
        """
        Returns a list of Encoding objects
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.encodings(factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param str video_id: Id of a Video. When specified, the resulting list will contain videos that belong to the Video.
        :param str status: One of `success`, `fail`, `processing`. When specified, the resulting list will contain ecodings filtered by status.
        :param str profile_id: Filter by profile_id.
        :param str profile_name: Filter by profile_name.
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param bool screenshots: Determines whether the response will include screenshots. By default this is not set.
        :param bool precise_status: Determines whether the response will include a precise status. By default this is not set.
        :return: PaginatedEncodingsCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.encodings_with_http_info(factory_id, **kwargs)
        else:
            (data) = self.encodings_with_http_info(factory_id, **kwargs)
            return data

    def encodings_with_http_info(self, factory_id, **kwargs):
        """
        Returns a list of Encoding objects
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.encodings_with_http_info(factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param str video_id: Id of a Video. When specified, the resulting list will contain videos that belong to the Video.
        :param str status: One of `success`, `fail`, `processing`. When specified, the resulting list will contain ecodings filtered by status.
        :param str profile_id: Filter by profile_id.
        :param str profile_name: Filter by profile_name.
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param bool screenshots: Determines whether the response will include screenshots. By default this is not set.
        :param bool precise_status: Determines whether the response will include a precise status. By default this is not set.
        :return: PaginatedEncodingsCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['factory_id', 'video_id', 'status', 'profile_id', 'profile_name', 'page', 'per_page', 'screenshots', 'precise_status']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method encodings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `encodings`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))
        if 'video_id' in params:
            query_params.append(('video_id', params['video_id']))
        if 'status' in params:
            query_params.append(('status', params['status']))
        if 'profile_id' in params:
            query_params.append(('profile_id', params['profile_id']))
        if 'profile_name' in params:
            query_params.append(('profile_name', params['profile_name']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'screenshots' in params:
            query_params.append(('screenshots', params['screenshots']))
        if 'precise_status' in params:
            query_params.append(('precise_status', params['precise_status']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/encodings.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PaginatedEncodingsCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def encodings_count(self, factory_id, **kwargs):
        """
        Returns a number of Encoding objects created using a given factory.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.encodings_count(factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :return: CountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.encodings_count_with_http_info(factory_id, **kwargs)
        else:
            (data) = self.encodings_count_with_http_info(factory_id, **kwargs)
            return data

    def encodings_count_with_http_info(self, factory_id, **kwargs):
        """
        Returns a number of Encoding objects created using a given factory.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.encodings_count_with_http_info(factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :return: CountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['factory_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method encodings_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `encodings_count`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/encodings/count.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CountResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def factories(self, **kwargs):
        """
        Returns a collection of Factory objects.
        Returns a collection of Factory objects.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.factories(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param bool with_storage_provider: if set to `true`, results will include a storage provider's id
        :return: PaginatedFactoryCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.factories_with_http_info(**kwargs)
        else:
            (data) = self.factories_with_http_info(**kwargs)
            return data

    def factories_with_http_info(self, **kwargs):
        """
        Returns a collection of Factory objects.
        Returns a collection of Factory objects.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.factories_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param bool with_storage_provider: if set to `true`, results will include a storage provider's id
        :return: PaginatedFactoryCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'per_page', 'with_storage_provider']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method factories" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'with_storage_provider' in params:
            query_params.append(('with_storage_provider', params['with_storage_provider']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/factories.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PaginatedFactoryCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def factory(self, id, **kwargs):
        """
        Returns a Factory object.
        Returns a Factory object.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.factory(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id of a factory (required)
        :param bool with_storage_provider: if set to `true`, results will include a storage provider's id
        :return: Factory
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.factory_with_http_info(id, **kwargs)
        else:
            (data) = self.factory_with_http_info(id, **kwargs)
            return data

    def factory_with_http_info(self, id, **kwargs):
        """
        Returns a Factory object.
        Returns a Factory object.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.factory_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id of a factory (required)
        :param bool with_storage_provider: if set to `true`, results will include a storage provider's id
        :return: Factory
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'with_storage_provider']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method factory" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `factory`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'with_storage_provider' in params:
            query_params.append(('with_storage_provider', params['with_storage_provider']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/factories/{id}.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Factory',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def notifications(self, factory_id, **kwargs):
        """
        Returns a Factory's notification settings.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.notifications(factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :return: CloudNotificationSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.notifications_with_http_info(factory_id, **kwargs)
        else:
            (data) = self.notifications_with_http_info(factory_id, **kwargs)
            return data

    def notifications_with_http_info(self, factory_id, **kwargs):
        """
        Returns a Factory's notification settings.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.notifications_with_http_info(factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :return: CloudNotificationSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['factory_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method notifications" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `notifications`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/notifications.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CloudNotificationSettings',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def profile(self, id_or_name, factory_id, **kwargs):
        """
        Returns a Profile object.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.profile(id_or_name, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id_or_name: A name or an id of a Profile. (required)
        :param str factory_id: Id of a Factory. (required)
        :param bool expand: If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set.
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.profile_with_http_info(id_or_name, factory_id, **kwargs)
        else:
            (data) = self.profile_with_http_info(id_or_name, factory_id, **kwargs)
            return data

    def profile_with_http_info(self, id_or_name, factory_id, **kwargs):
        """
        Returns a Profile object.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.profile_with_http_info(id_or_name, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id_or_name: A name or an id of a Profile. (required)
        :param str factory_id: Id of a Factory. (required)
        :param bool expand: If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set.
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_or_name', 'factory_id', 'expand']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_or_name' is set
        if ('id_or_name' not in params) or (params['id_or_name'] is None):
            raise ValueError("Missing the required parameter `id_or_name` when calling `profile`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `profile`")


        collection_formats = {}

        path_params = {}
        if 'id_or_name' in params:
            path_params['id_or_name'] = params['id_or_name']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))
        if 'expand' in params:
            query_params.append(('expand', params['expand']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/profiles/{id_or_name}.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Profile',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def profile_encodings(self, id_or_name, factory_id, **kwargs):
        """
        Returns a list of Encodings that belong to a Profile.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.profile_encodings(id_or_name, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id_or_name: Id or name of a Profile. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: PaginatedEncodingsCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.profile_encodings_with_http_info(id_or_name, factory_id, **kwargs)
        else:
            (data) = self.profile_encodings_with_http_info(id_or_name, factory_id, **kwargs)
            return data

    def profile_encodings_with_http_info(self, id_or_name, factory_id, **kwargs):
        """
        Returns a list of Encodings that belong to a Profile.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.profile_encodings_with_http_info(id_or_name, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id_or_name: Id or name of a Profile. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: PaginatedEncodingsCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_or_name', 'factory_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method profile_encodings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_or_name' is set
        if ('id_or_name' not in params) or (params['id_or_name'] is None):
            raise ValueError("Missing the required parameter `id_or_name` when calling `profile_encodings`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `profile_encodings`")


        collection_formats = {}

        path_params = {}
        if 'id_or_name' in params:
            path_params['id_or_name'] = params['id_or_name']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/profiles/{id_or_name}/encodings.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PaginatedEncodingsCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def profiles(self, factory_id, **kwargs):
        """
        Returns a collection of Profile objects.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.profiles(factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param bool exclude_advanced_services: Determine whether exclude Advanced Services profiles from the results. By default this is not set.
        :param bool expand: If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set.
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :return: PaginatedProfilesCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.profiles_with_http_info(factory_id, **kwargs)
        else:
            (data) = self.profiles_with_http_info(factory_id, **kwargs)
            return data

    def profiles_with_http_info(self, factory_id, **kwargs):
        """
        Returns a collection of Profile objects.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.profiles_with_http_info(factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param bool exclude_advanced_services: Determine whether exclude Advanced Services profiles from the results. By default this is not set.
        :param bool expand: If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set.
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :return: PaginatedProfilesCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['factory_id', 'exclude_advanced_services', 'expand', 'page', 'per_page']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method profiles" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `profiles`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))
        if 'exclude_advanced_services' in params:
            query_params.append(('exclude_advanced_services', params['exclude_advanced_services']))
        if 'expand' in params:
            query_params.append(('expand', params['expand']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/profiles.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PaginatedProfilesCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def queued_videos(self, factory_id, **kwargs):
        """
        Returns a collection of Video objects queued for encoding.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.queued_videos(factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :return: PaginatedVideoCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.queued_videos_with_http_info(factory_id, **kwargs)
        else:
            (data) = self.queued_videos_with_http_info(factory_id, **kwargs)
            return data

    def queued_videos_with_http_info(self, factory_id, **kwargs):
        """
        Returns a collection of Video objects queued for encoding.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.queued_videos_with_http_info(factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :return: PaginatedVideoCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['factory_id', 'page', 'per_page']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method queued_videos" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `queued_videos`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/videos/queued.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PaginatedVideoCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def resubmit_video(self, factory_id, resubmit_video_body, **kwargs):
        """
        Resubmits a video to encode.
        Resubmits the video to encode. Please note that this option will work only for videos in `success` status.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.resubmit_video(factory_id, resubmit_video_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param ResubmitVideoBody resubmit_video_body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.resubmit_video_with_http_info(factory_id, resubmit_video_body, **kwargs)
        else:
            (data) = self.resubmit_video_with_http_info(factory_id, resubmit_video_body, **kwargs)
            return data

    def resubmit_video_with_http_info(self, factory_id, resubmit_video_body, **kwargs):
        """
        Resubmits a video to encode.
        Resubmits the video to encode. Please note that this option will work only for videos in `success` status.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.resubmit_video_with_http_info(factory_id, resubmit_video_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param ResubmitVideoBody resubmit_video_body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['factory_id', 'resubmit_video_body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resubmit_video" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `resubmit_video`")
        # verify the required parameter 'resubmit_video_body' is set
        if ('resubmit_video_body' not in params) or (params['resubmit_video_body'] is None):
            raise ValueError("Missing the required parameter `resubmit_video_body` when calling `resubmit_video`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'resubmit_video_body' in params:
            body_params = params['resubmit_video_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/videos/resubmit.json', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def retry_encoding(self, id, factory_id, **kwargs):
        """
        Retries a failed encoding.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.retry_encoding(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: RetriedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.retry_encoding_with_http_info(id, factory_id, **kwargs)
        else:
            (data) = self.retry_encoding_with_http_info(id, factory_id, **kwargs)
            return data

    def retry_encoding_with_http_info(self, id, factory_id, **kwargs):
        """
        Retries a failed encoding.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.retry_encoding_with_http_info(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: RetriedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'factory_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retry_encoding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retry_encoding`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `retry_encoding`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/encodings/{id}/retry.json', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='RetriedResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def signed_encoding_url(self, id, factory_id, **kwargs):
        """
        Returns a signed url pointing to an Encoding.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.signed_encoding_url(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: EncodingSignedUrl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.signed_encoding_url_with_http_info(id, factory_id, **kwargs)
        else:
            (data) = self.signed_encoding_url_with_http_info(id, factory_id, **kwargs)
            return data

    def signed_encoding_url_with_http_info(self, id, factory_id, **kwargs):
        """
        Returns a signed url pointing to an Encoding.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.signed_encoding_url_with_http_info(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: EncodingSignedUrl
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'factory_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method signed_encoding_url" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `signed_encoding_url`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `signed_encoding_url`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/encodings/{id}/signed-url.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EncodingSignedUrl',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def signed_encoding_urls(self, id, factory_id, **kwargs):
        """
        Returns a list of signed urls pointing to an Encoding's outputs.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.signed_encoding_urls(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: EncodingSignedUrls
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.signed_encoding_urls_with_http_info(id, factory_id, **kwargs)
        else:
            (data) = self.signed_encoding_urls_with_http_info(id, factory_id, **kwargs)
            return data

    def signed_encoding_urls_with_http_info(self, id, factory_id, **kwargs):
        """
        Returns a list of signed urls pointing to an Encoding's outputs.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.signed_encoding_urls_with_http_info(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: EncodingSignedUrls
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'factory_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method signed_encoding_urls" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `signed_encoding_urls`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `signed_encoding_urls`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/encodings/{id}/signed-urls.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EncodingSignedUrls',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def signed_video_url(self, id, factory_id, **kwargs):
        """
        Returns a signed url pointing to a Video.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.signed_video_url(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: SignedVideoUrl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.signed_video_url_with_http_info(id, factory_id, **kwargs)
        else:
            (data) = self.signed_video_url_with_http_info(id, factory_id, **kwargs)
            return data

    def signed_video_url_with_http_info(self, id, factory_id, **kwargs):
        """
        Returns a signed url pointing to a Video.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.signed_video_url_with_http_info(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: SignedVideoUrl
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'factory_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method signed_video_url" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `signed_video_url`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `signed_video_url`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/videos/{id}/signed-url.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SignedVideoUrl',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def toggle_factory_sync(self, id, factory_sync_body, **kwargs):
        """
        Toggles synchronisation settings.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.toggle_factory_sync(id, factory_sync_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id of the factory (required)
        :param FactorySyncBody factory_sync_body: (required)
        :return: FactorySync
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.toggle_factory_sync_with_http_info(id, factory_sync_body, **kwargs)
        else:
            (data) = self.toggle_factory_sync_with_http_info(id, factory_sync_body, **kwargs)
            return data

    def toggle_factory_sync_with_http_info(self, id, factory_sync_body, **kwargs):
        """
        Toggles synchronisation settings.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.toggle_factory_sync_with_http_info(id, factory_sync_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id of the factory (required)
        :param FactorySyncBody factory_sync_body: (required)
        :return: FactorySync
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'factory_sync_body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method toggle_factory_sync" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `toggle_factory_sync`")
        # verify the required parameter 'factory_sync_body' is set
        if ('factory_sync_body' not in params) or (params['factory_sync_body'] is None):
            raise ValueError("Missing the required parameter `factory_sync_body` when calling `toggle_factory_sync`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'factory_sync_body' in params:
            body_params = params['factory_sync_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/factories/{id}/sync.json', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FactorySync',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_encoding(self, id, factory_id, update_encoding_body, **kwargs):
        """
        Updates an Encoding
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_encoding(id, factory_id, update_encoding_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param UpdateEncodingBody update_encoding_body: (required)
        :param bool screenshots: Determines whether the response will include screenshots. By default this is not set.
        :param bool precise_status: Determines whether the response will include a precise status. By default this is not set.
        :return: Encoding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_encoding_with_http_info(id, factory_id, update_encoding_body, **kwargs)
        else:
            (data) = self.update_encoding_with_http_info(id, factory_id, update_encoding_body, **kwargs)
            return data

    def update_encoding_with_http_info(self, id, factory_id, update_encoding_body, **kwargs):
        """
        Updates an Encoding
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_encoding_with_http_info(id, factory_id, update_encoding_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param UpdateEncodingBody update_encoding_body: (required)
        :param bool screenshots: Determines whether the response will include screenshots. By default this is not set.
        :param bool precise_status: Determines whether the response will include a precise status. By default this is not set.
        :return: Encoding
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'factory_id', 'update_encoding_body', 'screenshots', 'precise_status']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_encoding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_encoding`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `update_encoding`")
        # verify the required parameter 'update_encoding_body' is set
        if ('update_encoding_body' not in params) or (params['update_encoding_body'] is None):
            raise ValueError("Missing the required parameter `update_encoding_body` when calling `update_encoding`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))
        if 'screenshots' in params:
            query_params.append(('screenshots', params['screenshots']))
        if 'precise_status' in params:
            query_params.append(('precise_status', params['precise_status']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_encoding_body' in params:
            body_params = params['update_encoding_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/encodings/{id}.json', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Encoding',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_factory(self, id, update_factory_body, **kwargs):
        """
        Updates a Factory's settings. Returns a Factory object.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_factory(id, update_factory_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id of the factory (required)
        :param FactoryBody update_factory_body: (required)
        :param bool with_storage_provider: if set to `true`, results will include a storage provider's id
        :return: Factory
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_factory_with_http_info(id, update_factory_body, **kwargs)
        else:
            (data) = self.update_factory_with_http_info(id, update_factory_body, **kwargs)
            return data

    def update_factory_with_http_info(self, id, update_factory_body, **kwargs):
        """
        Updates a Factory's settings. Returns a Factory object.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_factory_with_http_info(id, update_factory_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id of the factory (required)
        :param FactoryBody update_factory_body: (required)
        :param bool with_storage_provider: if set to `true`, results will include a storage provider's id
        :return: Factory
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'update_factory_body', 'with_storage_provider']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_factory" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_factory`")
        # verify the required parameter 'update_factory_body' is set
        if ('update_factory_body' not in params) or (params['update_factory_body'] is None):
            raise ValueError("Missing the required parameter `update_factory_body` when calling `update_factory`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'with_storage_provider' in params:
            query_params.append(('with_storage_provider', params['with_storage_provider']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_factory_body' in params:
            body_params = params['update_factory_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/factories/{id}.json', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Factory',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_notifications(self, factory_id, cloud_notification_settings_body, **kwargs):
        """
        Updates a Factory's notification settings.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_notifications(factory_id, cloud_notification_settings_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param CloudNotificationSettings cloud_notification_settings_body: (required)
        :return: CloudNotificationSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_notifications_with_http_info(factory_id, cloud_notification_settings_body, **kwargs)
        else:
            (data) = self.update_notifications_with_http_info(factory_id, cloud_notification_settings_body, **kwargs)
            return data

    def update_notifications_with_http_info(self, factory_id, cloud_notification_settings_body, **kwargs):
        """
        Updates a Factory's notification settings.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_notifications_with_http_info(factory_id, cloud_notification_settings_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param CloudNotificationSettings cloud_notification_settings_body: (required)
        :return: CloudNotificationSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['factory_id', 'cloud_notification_settings_body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_notifications" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `update_notifications`")
        # verify the required parameter 'cloud_notification_settings_body' is set
        if ('cloud_notification_settings_body' not in params) or (params['cloud_notification_settings_body'] is None):
            raise ValueError("Missing the required parameter `cloud_notification_settings_body` when calling `update_notifications`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cloud_notification_settings_body' in params:
            body_params = params['cloud_notification_settings_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/notifications.json', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CloudNotificationSettings',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_profile(self, id, factory_id, update_profile_body, **kwargs):
        """
        Updates a given Profile
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_profile(id, factory_id, update_profile_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param str factory_id: Id of a Factory. (required)
        :param ProfileBody update_profile_body: (required)
        :param bool exclude_advanced_services:
        :param bool expand: If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set.
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_profile_with_http_info(id, factory_id, update_profile_body, **kwargs)
        else:
            (data) = self.update_profile_with_http_info(id, factory_id, update_profile_body, **kwargs)
            return data

    def update_profile_with_http_info(self, id, factory_id, update_profile_body, **kwargs):
        """
        Updates a given Profile
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_profile_with_http_info(id, factory_id, update_profile_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param str factory_id: Id of a Factory. (required)
        :param ProfileBody update_profile_body: (required)
        :param bool exclude_advanced_services:
        :param bool expand: If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set.
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'factory_id', 'update_profile_body', 'exclude_advanced_services', 'expand']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_profile`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `update_profile`")
        # verify the required parameter 'update_profile_body' is set
        if ('update_profile_body' not in params) or (params['update_profile_body'] is None):
            raise ValueError("Missing the required parameter `update_profile_body` when calling `update_profile`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))
        if 'exclude_advanced_services' in params:
            query_params.append(('exclude_advanced_services', params['exclude_advanced_services']))
        if 'expand' in params:
            query_params.append(('expand', params['expand']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_profile_body' in params:
            body_params = params['update_profile_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/profiles/{id}.json', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Profile',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def upload_video(self, factory_id, video_upload_body, **kwargs):
        """
        Creates an upload session.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_video(factory_id, video_upload_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param VideoUploadBody video_upload_body: (required)
        :return: UploadSession
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.upload_video_with_http_info(factory_id, video_upload_body, **kwargs)
        else:
            (data) = self.upload_video_with_http_info(factory_id, video_upload_body, **kwargs)
            return data

    def upload_video_with_http_info(self, factory_id, video_upload_body, **kwargs):
        """
        Creates an upload session.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_video_with_http_info(factory_id, video_upload_body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param VideoUploadBody video_upload_body: (required)
        :return: UploadSession
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['factory_id', 'video_upload_body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_video" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `upload_video`")
        # verify the required parameter 'video_upload_body' is set
        if ('video_upload_body' not in params) or (params['video_upload_body'] is None):
            raise ValueError("Missing the required parameter `video_upload_body` when calling `upload_video`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'video_upload_body' in params:
            body_params = params['video_upload_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/videos/upload.json', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='UploadSession',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def video(self, id, factory_id, **kwargs):
        """
        Returns a Video object.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.video(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: Video
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.video_with_http_info(id, factory_id, **kwargs)
        else:
            (data) = self.video_with_http_info(id, factory_id, **kwargs)
            return data

    def video_with_http_info(self, id, factory_id, **kwargs):
        """
        Returns a Video object.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.video_with_http_info(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: Video
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'factory_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method video" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `video`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `video`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/videos/{id}.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Video',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def video_encodings(self, id, factory_id, **kwargs):
        """
        Returns a list of Encodings that belong to a Video.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.video_encodings(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param bool screenshots: Determines whether the response will include screenshots. By default this is not set.
        :param bool precise_status: Determines whether the response will include a precise status. By default this is not set.
        :return: PaginatedEncodingsCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.video_encodings_with_http_info(id, factory_id, **kwargs)
        else:
            (data) = self.video_encodings_with_http_info(id, factory_id, **kwargs)
            return data

    def video_encodings_with_http_info(self, id, factory_id, **kwargs):
        """
        Returns a list of Encodings that belong to a Video.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.video_encodings_with_http_info(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param bool screenshots: Determines whether the response will include screenshots. By default this is not set.
        :param bool precise_status: Determines whether the response will include a precise status. By default this is not set.
        :return: PaginatedEncodingsCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'factory_id', 'page', 'per_page', 'screenshots', 'precise_status']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method video_encodings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `video_encodings`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `video_encodings`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'screenshots' in params:
            query_params.append(('screenshots', params['screenshots']))
        if 'precise_status' in params:
            query_params.append(('precise_status', params['precise_status']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/videos/{id}/encodings.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PaginatedEncodingsCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def video_metadata(self, id, factory_id, **kwargs):
        """
        Returns a Video's metadata
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.video_metadata(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: VideoMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.video_metadata_with_http_info(id, factory_id, **kwargs)
        else:
            (data) = self.video_metadata_with_http_info(id, factory_id, **kwargs)
            return data

    def video_metadata_with_http_info(self, id, factory_id, **kwargs):
        """
        Returns a Video's metadata
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.video_metadata_with_http_info(id, factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :return: VideoMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'factory_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method video_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `video_metadata`")
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `video_metadata`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/videos/{id}/metadata.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VideoMetadata',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def videos(self, factory_id, **kwargs):
        """
        Returns a collection of Video objects.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.videos(factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :return: PaginatedVideoCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.videos_with_http_info(factory_id, **kwargs)
        else:
            (data) = self.videos_with_http_info(factory_id, **kwargs)
            return data

    def videos_with_http_info(self, factory_id, **kwargs):
        """
        Returns a collection of Video objects.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.videos_with_http_info(factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :return: PaginatedVideoCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['factory_id', 'page', 'per_page']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method videos" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `videos`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/videos.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PaginatedVideoCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def workflows(self, factory_id, **kwargs):
        """
        Returns a collection of Workflows that belong to a Factory.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.workflows(factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :return: PaginatedWorkflowsCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.workflows_with_http_info(factory_id, **kwargs)
        else:
            (data) = self.workflows_with_http_info(factory_id, **kwargs)
            return data

    def workflows_with_http_info(self, factory_id, **kwargs):
        """
        Returns a collection of Workflows that belong to a Factory.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.workflows_with_http_info(factory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str factory_id: Id of a Factory. (required)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :return: PaginatedWorkflowsCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['factory_id', 'page', 'per_page']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workflows" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'factory_id' is set
        if ('factory_id' not in params) or (params['factory_id'] is None):
            raise ValueError("Missing the required parameter `factory_id` when calling `workflows`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in params:
            query_params.append(('factory_id', params['factory_id']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/workflows.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PaginatedWorkflowsCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
